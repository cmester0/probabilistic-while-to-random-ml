\documentclass[11pt, leqno]{article}

\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage[english]{babel}

\usepackage[left=20mm,right=20mm]{geometry}

\usepackage[hidelinks]{hyperref}

\usepackage{xcolor}

\usepackage{listings}

\lstdefinelanguage{rml}{
}

\lstdefinelanguage{pwhile}{
}

\author{Lasse Letager Hansen 201508114}
\date{\today}
\title{Technical report}

\newcommand{\set}[1]{\{#1\}}

\newcommand{\Rml}{\textcolor{orange}{\mathtt{Rml}}}
\newcommand{\sRml}{\textcolor{orange}{\mathtt{sRml}}}
\newcommand{\Type}{\textcolor{blue}{\mathtt{Type}}}
\newcommand{\wellformed}{\texttt{well\_formed}}
\newcommand{\valid}{\texttt{rml\_valid\_type}}
\newcommand{\bind}{\textcolor{magenta}{>\!\!>\!\!=}}

\begin{document}

\maketitle

\section{Rml}
We have two representations of Rml, continuations and distributions. Both build on a monad, for ease of use.
\\ \\
The data structure used to represent Rml terms is as follows:
\begin{align*}
  &\mathtt{Inductive}~\Rml : \Type := \\
  &~~|~ \mathtt{Var} : (\mathbb{N} * \Type) \rightarrow \Rml \\
  &~~|~ \mathtt{Const} : \forall~(A : \Type),~A \rightarrow \Rml \\
  &~~|~ \mathtt{Let\_stm} : (\mathbb{N} * \Type) \rightarrow \Rml \rightarrow \Rml \rightarrow \Rml \\
  &~~|~ \mathtt{If\_stm} : \Rml \rightarrow \Rml \rightarrow \Rml \rightarrow \Rml \\
  &~~|~ \mathtt{App\_stm} : \Type \rightarrow \Rml \rightarrow \Rml \rightarrow \Rml \\
  &~~|~ \mathtt{Let\_rec} : (\mathbb{N} * \Type) \rightarrow (\mathbb{N} * \Type) \rightarrow \Rml \rightarrow \Rml \rightarrow \Rml.
\end{align*}
We use all cog types, as possible types of Rml expressions, since there are no real restrictions on the types. We encode variables, as a type and a natural number, so two variables are the same only if they have the same number and refer to the same type.
\\ \\
We have defined a relation \wellformed, that checks that no variables are escaping the scope of an Rml program, that is there is always a binding for an expression of type \(\mathtt{Var}~p\). We furthermore define a relation \valid, which checks that a given Rml expression can be typed under a given type. We have shown that if a Rml program is valid then it is well formed. We have then constructed a simplified form of Rml called sRml (for simple Rml), to make it easier to reason about and evaluate expressions, with the following data structure:
\begin{align*}
  &\mathtt{Inductive}~\sRml : \Type := \\
  &~~|~ \mathtt{sVar} : (\mathbb{N} * \Type) \rightarrow \sRml \\
  &~~|~ \mathtt{sConst} : \forall~(A : \Type),~A \rightarrow \sRml \\
  &~~|~ \mathtt{sIf} : \sRml \rightarrow \sRml \rightarrow \sRml \rightarrow \sRml \\
  &~~|~ \mathtt{sApp} : \Type \rightarrow \sRml \rightarrow \sRml \rightarrow \sRml \\
  &~~|~ \mathtt{sFix} : \forall~(p~p0 : (\mathbb{N} * \Type)),~@\sRml~p.2 \rightarrow @\sRml~(p.2 \rightarrow A) \rightarrow \sRml.
\end{align*}
That is Rml where we remove expressions with variables, from \texttt{let\_stm} statements (not \texttt{let\_rec} statements). We then show that given a valid typing of an Rml expression, we can simplify that expression, and maintain the valid typing (under the same type). With this we can make an interpreter from an interpreter of sRml, which can be constructed as (for continuations). We have a similar function for Rml, using the posibility distributions as interpretations. We see similar patterns arising, since both interpretations are monadic.

\section{Translation from Rml to typed $\mathbf{\lambda}$-calculus}
\begin{center}
  \begin{tabular}{|c|c|}
    \hline
    Rml & typed $\lambda$-calculus \\ \hline
    Var $(x,A)$ & $x : A$ \\
    Const $A$ $c$ & $c : A$ \\
    Let $(x,A)$ $e_1$ $e_2$ & $(\lambda x : A, e_2)~e_1$ \\
    Fun $(x,A)$ $e$ & $\lambda x : A, e$ \\
    App $e_1$ $e_2$ & $e_1~e_2$ \\
    Let rec $(f,A \rightarrow B)$ $(x,A)$ $e_1$ $e_2$ & $(\lambda f : A \rightarrow B, e_2)~(Y~(\lambda f : A \rightarrow B, \lambda x : A, e_1))$ \\ \hline
  \end{tabular}
\end{center}
The problem here is that we need to translate \(e1\) and \(e2\) to their simple forms.

\subsection{Example: Fib}
Expression:
\begin{align*}
\mathtt{Let\_rec}&~(f,\mathbb{N} \rightarrow \mathbb{N})~(x,\mathbb{N})~\\
  (&\mathtt{if}~x \leq 0\\
                 &\mathtt{then}~0\\
                 &\mathtt{else}~f~(x - 1) + f~(x-2))\\
  (&f~3)
\end{align*}
Typing:
\begin{align*}
\mathtt{Let\_rec}&~(f,\mathbb{N} \rightarrow \mathbb{N})~(x,\mathbb{N})~\\
  (&\mathtt{if}~x \leq 0\\
                 &\mathtt{then}~0\\
                 &\mathtt{else}~f~(x - 1) + f~(x-2) : \mathbb{N})\\
  (&(f : \mathbb{N} \rightarrow \mathbb{N})~(3 : \mathbb{N}) : \mathbb{N})
\end{align*}
Simple form:
\[\mathtt{Let\_rec~(f,\mathbb{N} \rightarrow \mathbb{N})~(x,A)~}\]

\end{document}
