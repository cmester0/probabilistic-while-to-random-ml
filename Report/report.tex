\documentclass[11pt, leqno]{article}

\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage[english]{babel}

\usepackage[left=20mm,right=20mm]{geometry}

\usepackage[hidelinks]{hyperref}

\usepackage{xcolor}

\usepackage{listings}

\lstdefinelanguage{rml}{
}

\lstdefinelanguage{pwhile}{
}

\author{Lasse Letager Hansen 201508114}
\date{\today}
\title{Technical report}

\newcommand{\set}[1]{\{#1\}}

\newcommand{\Rml}{\textcolor{orange}{\mathtt{Rml}}}
\newcommand{\sRml}{\textcolor{orange}{\mathtt{sRml}}}
\newcommand{\Type}{\textcolor{blue}{\mathtt{Type}}}
\newcommand{\wellformed}{\texttt{well\_formed}}
\newcommand{\valid}{\texttt{rml\_valid\_type}}
\newcommand{\bind}{\textcolor{magenta}{>\!\!>\!\!=}}

\begin{document}

% -------------------------------------------------------------

\newcommand\rml{$\mathcal{R}$\texttt{ml} } % for a pretty version of "Rml"
\newcommand\M{\texttt{M}} % for the M representing monads

% -------------------------------------------------------------

\maketitle

\tableofcontents
\newpage

% ------------------------------------------------------------- 

\section{Introduction}
% Goal: 1-2 pages
% I've written an introduction already, but I don't know if it still fits. We should
% probably write the rest of the report first before adding this section

% here we should write something about the motivation of the project and give an
% overview of what Coq/formal verification is, some very basic things about
% cryptography, and how they relate.


\section{Theory and existing frameworks}
% Goal: 6-12 pages

\subsection{\rml}
We have two representations of Rml, continuations and distributions. Both build on a monad, for ease of use.
\\ \\
The data structure used to represent Rml terms is as follows:
\begin{align*}
  &\mathtt{Inductive}~\Rml : \Type := \\
  &~~|~ \mathtt{Var} : (\mathbb{N} * \Type) \rightarrow \Rml \\
  &~~|~ \mathtt{Const} : \forall~(A : \Type),~A \rightarrow \Rml \\
  &~~|~ \mathtt{Let\_stm} : (\mathbb{N} * \Type) \rightarrow \Rml \rightarrow \Rml \rightarrow \Rml \\
  &~~|~ \mathtt{If\_stm} : \Rml \rightarrow \Rml \rightarrow \Rml \rightarrow \Rml \\
  &~~|~ \mathtt{App\_stm} : \Type \rightarrow \Rml \rightarrow \Rml \rightarrow \Rml \\
  &~~|~ \mathtt{Let\_rec} : (\mathbb{N} * \Type) \rightarrow (\mathbb{N} * \Type) \rightarrow \Rml \rightarrow \Rml \rightarrow \Rml.
\end{align*}
We use all cog types, as possible types of Rml expressions, since there are no real restrictions on the types. We encode variables, as a type and a natural number, so two variables are the same only if they have the same number and refer to the same type.
\\ \\
We have defined a relation \wellformed, that checks that no variables are escaping the scope of an Rml program, that is there is always a binding for an expression of type \(\mathtt{Var}~p\). We furthermore define a relation \valid, which checks that a given Rml expression can be typed under a given type. We have shown that if a Rml program is valid then it is well formed. We have then constructed a simplified form of Rml called sRml (for simple Rml), to make it easier to reason about and evaluate expressions, with the following data structure:
\begin{align*}
  &\mathtt{Inductive}~\sRml : \Type := \\
  &~~|~ \mathtt{sVar} : (\mathbb{N} * \Type) \rightarrow \sRml \\
  &~~|~ \mathtt{sConst} : \forall~(A : \Type),~A \rightarrow \sRml \\
  &~~|~ \mathtt{sIf} : \sRml \rightarrow \sRml \rightarrow \sRml \rightarrow \sRml \\
  &~~|~ \mathtt{sApp} : \Type \rightarrow \sRml \rightarrow \sRml \rightarrow \sRml \\
  &~~|~ \mathtt{sFix} : \forall~(p~p0 : (\mathbb{N} * \Type)),~@\sRml~p.2 \rightarrow @\sRml~(p.2 \rightarrow A) \rightarrow \sRml.
\end{align*}
That is Rml where we remove expressions with variables, from \texttt{let\_stm} statements (not \texttt{let\_rec} statements). We then show that given a valid typing of an Rml expression, we can simplify that expression, and maintain the valid typing (under the same type). With this we can make an interpreter from an interpreter of sRml, which can be constructed as (for continuations). We have a similar function for Rml, using the posibility distributions as interpretations. We see similar patterns arising, since both interpretations are monadic.

\subsection{\texttt{pwhile}}
% Here we should give a quick description of EasyCrypt an present pwhile


\section{Our approach}
% Goal: 6-12 pages

% What we tried to do and the theory behind.

% Describe the translation from while to functional (+recursion), to lambda-calculus,
% to an interpretation in omega-cpos.

% We planned on making an interpretation of Rml in Coq and then translating the xhl
% implementation of pwhile to our abstract syntax. 



\subsection{Translation from Rml to typed $\mathbf{\lambda}$-calculus}
\begin{center}
  \begin{tabular}{|c|c|}
    \hline
    Rml & typed $\lambda$-calculus \\ \hline
    Var $(x,A)$ & $x : A$ \\
    Const $A$ $c$ & $c : A$ \\
    Let $(x,A)$ $e_1$ $e_2$ & $(\lambda x : A, e_2)~e_1$ \\
    Fun $(x,A)$ $e$ & $\lambda x : A, e$ \\
    App $e_1$ $e_2$ & $e_1~e_2$ \\
    Let rec $(f,A \rightarrow B)$ $(x,A)$ $e_1$ $e_2$ & $(\lambda f : A \rightarrow B, e_2)~(Y~(\lambda f : A \rightarrow B, \lambda x : A, e_1))$ \\ \hline
  \end{tabular}
\end{center}
The problem here is that we need to translate \(e1\) and \(e2\) to their simple forms, so we do an intermediate translation:
\[Let\]

\subsubsection{Example: Fib}
Expression:
\begin{align*}
\mathtt{Let\_rec}&~(f,\mathbb{N} \rightarrow \mathbb{N})~(x,\mathbb{N})~\\
  (&\mathtt{if}~x \leq 0\\
                 &\mathtt{then}~0\\
                 &\mathtt{else}~f~(x - 1) + f~(x-2))\\
  (&f~3)
\end{align*}
Typing:
\begin{align*}
\mathtt{Let\_rec}&~(f,\mathbb{N} \rightarrow \mathbb{N})~(x,\mathbb{N})~\\
  ((&\mathtt{if}~(x \leq 0 : \mathbb{B})\\
                 &\mathtt{then}~(0 : \mathbb{N})\\
                 &\mathtt{else}~(f : \mathbb{N} \rightarrow \mathbb{N})~(x - 1 : \mathbb{N}) + (f : \mathbb{N} \rightarrow \mathbb{N})~(x-2 : \mathbb{N}) : \mathbb{N}) : \mathbb{N})\\
  (&(f : \mathbb{N} \rightarrow \mathbb{N})~(3 : \mathbb{N}) : \mathbb{N})
\end{align*}
Semi-simple
\begin{align*}
  &\mathtt{Let\_stm}~f \\
  &\quad \mathtt{sFix} \\
  &\quad \quad \mathtt{sFun}~(f,\mathbb{N} \rightarrow \mathbb{N})\\
  &\quad \quad \quad \mathtt{sFun}~(x,\mathbb{N}) \\
  &\quad \quad \quad \quad ((\mathtt{if}~(x \leq 0)\\
  &\quad \quad \quad \quad ~~\mathtt{then}~0\\
  &\quad \quad \quad \quad ~~\mathtt{else}~f~(x - 1) + f~(x-2)))\\
  &\quad (f~3)
\end{align*}
Simple form:
\begin{align*}
  &\mathtt{sApp}~\mathtt{sFix} \\
  &\quad \mathtt{sFun}~(f,\mathbb{N} \rightarrow \mathbb{N})\\
  &\quad \quad \mathtt{sFun}~(x,\mathbb{N}) \\
  &\quad \quad \quad ((\mathtt{if}~(x \leq 0)\\
  &\quad \quad \quad ~~\mathtt{then}~0\\
  &\quad \quad \quad ~~\mathtt{else}~f~(x - 1) + f~(x-2))) \\
  &\quad 3
\end{align*}

\subsection{All translations (forward)}
\begin{center}
  \begin{tabular}{|c|c|c|}
    \hline
    Rml & @sRml A & typed $\lambda$-calculus \\ \hline
    Var $(x,A)$ & sVar $x$ & $x : A$ \\
    Const $A$ $c$ & & $c : A$ \\
    Let $(x,A)$ $e_1$ $e_2$ & & $(\lambda x : A, e_2)~e_1$ \\
    Fun $(x,A)$ $e$ & & $\lambda x : A, e$ \\
    App $e_1$ $e_2$ & & $e_1~e_2$ \\
    Let rec $(f,A \rightarrow B)$ $(x,A)$ $e_1$ $e_2$ & & $(\lambda f : A \rightarrow B, e_2)~(Y~(\lambda f : A \rightarrow B, \lambda x : A, e_1))$ \\ \hline
  \end{tabular}
\end{center}


\section{Our contribution}
% Goal: 6-12 pages
% What we actually did.

% We implemented an abstract syntax for Rml in Coq

% We tried to translate from pwhile to said Rml (syntax to syntax)

% We were able to interpret Rml modulo general recursion, using a probability monad.

% We tried implementing general recursion with the extra step of translating to the
% typed lambda calculus and using a fixpoint combinator.

\section{Comparisons and future work}
% Goal: 2-4 pages
% What the section header says


\section{Conclusion}
% Goal: 1-2 pages



\newpage
\section{Appendix}
Example - Error: Stack Overflow.
\begin{lstlisting}
Fixpoint replace_all_variables_aux_type
         A (x : Rml) (env : seq (nat * Type * Rml))
         (fl : seq (nat * Type)) `{env_valid : valid_env env fl}
         `{x_valid : @rml_valid_type A (map fst env) fl x} : @sRml A
                                                                            
with replace_all_variables_aux_type_const
       A0 A a (env : seq (nat * Type * Rml))
       (fl : seq (nat * Type)) `{env_valid : valid_env env fl}
       `{x_valid : @rml_valid_type A0 (map fst env) fl (Const A a)} : @sRml A0
with replace_all_variables_aux_type_let
       A p x1 x2 (env : seq (nat * Type * Rml))
       (fl : seq (nat * Type)) `{env_valid : valid_env env fl}
       `{x_valid : @rml_valid_type A (map fst env) fl (Let_stm p x1 x2)} : @sRml A
with replace_all_variables_aux_type_fun
       A T p x (env : seq (nat * Type * Rml))
       (fl : seq (nat * Type)) `{env_valid : valid_env env fl}
       `{x_valid : @rml_valid_type A (map fst env) fl (Fun_stm T p x)} : @sRml A
with replace_all_variables_aux_type_if
       A x1 x2 x3 (env : seq (nat * Type * Rml))
       (fl : seq (nat * Type)) `{env_valid : valid_env env fl}
       `{x_valid : @rml_valid_type A (map fst env) fl (If_stm x1 x2 x3)} : @sRml A
with replace_all_variables_aux_type_app
       A T x1 x2 (env : seq (nat * Type * Rml))
       (fl : seq (nat * Type)) `{env_valid : valid_env env fl}
       `{x_valid : @rml_valid_type A (map fst env) fl (App_stm T x1 x2)} : @sRml A
with replace_all_variables_aux_type_let_rec A T T0 n n0 x1 x2 (env : seq (nat * Type * Rml))
     (fl : seq (nat * Type)) `{env_valid : valid_env env fl}
     `{x_valid : @rml_valid_type A (map fst env) fl (Let_rec T T0 n n0 x1 x2)} : @sRml A.
Proof.
  (** Structure **)
  {
    induction x ; intros ; refine (sVar (0,A)).
  }
  
  all: refine (sVar (0,A)).  
Defined.
\end{lstlisting}

\end{document}
