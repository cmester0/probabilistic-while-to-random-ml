% -------------------------------------------------------------
% Document setup
% -------------------------------------------------------------
\documentclass[11pt, leqno]{article}
\usepackage[left=20mm,right=20mm]{geometry}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
% -------------------------------------------------------------
% Notation aids 
% -------------------------------------------------------------
\usepackage{amsmath} % American Mathematical Society math-notations
\usepackage{amssymb} % American Mathematical Society math-symbols
\usepackage{stmaryrd} % For interpretation bracket (and maybe other stuff)
\usepackage{listings}

\lstdefinelanguage{rml}{
}

\lstdefinelanguage{pwhile}{
}
% -------------------------------------------------------------
% Prettyfying
% -------------------------------------------------------------
\usepackage[hidelinks]{hyperref}

\usepackage{xcolor}
% -------------------------------------------------------------

\author{Lasse Letager Hansen %201508114
  \\ Kira Kutscher %201509720
}
\date{\today}
\title{Technical report}

\newcommand{\set}[1]{\{#1\}}

\newcommand{\Rml}{\textcolor{orange}{\mathtt{Rml}}}
\newcommand{\sRml}{\textcolor{orange}{\mathtt{sRml}}}
\newcommand{\Type}{\textcolor{blue}{\mathtt{Type}}}
\newcommand{\wellformed}{\texttt{well\_formed}}
\newcommand{\valid}{\texttt{rml\_valid\_type}}
\newcommand{\bind}{\textcolor{magenta}{>\!\!>\!\!=}}

\begin{document}

% -------------------------------------------------------------

\newcommand\rml{$\mathcal{R}$\texttt{ml} } % for a pretty version of "Rml"
\newcommand\M{\texttt{M}} % for the M representing monads

% -------------------------------------------------------------

\maketitle

\tableofcontents
\newpage

% ------------------------------------------------------------- 

\section{Introduction}
% Goal: 1-2 pages
% I've written an introduction already, but I don't know if it still fits. We should
% probably write the rest of the report first before adding this section

% here we should write something about the motivation of the project and give an
% overview of what Coq/formal verification is, some very basic things about
% cryptography, and how they relate.


\section{Theory and existing frameworks}
% Goal: 6-12 pages

\subsection{\rml}
We have two representations of Rml, continuations and distributions. Both build on a monad, for ease of use.
\\ \\
The data structure used to represent Rml terms is as follows:
\begin{align*}
  &\mathtt{Inductive}~\Rml : \Type := \\
  &~~|~ \mathtt{Var} : (\mathbb{N} * \Type) \rightarrow \Rml \\
  &~~|~ \mathtt{Const} : \forall~(A : \Type),~A \rightarrow \Rml \\
  &~~|~ \mathtt{Let\_stm} : (\mathbb{N} * \Type) \rightarrow \Rml \rightarrow \Rml \rightarrow \Rml \\
  &~~|~ \mathtt{If\_stm} : \Rml \rightarrow \Rml \rightarrow \Rml \rightarrow \Rml \\
  &~~|~ \mathtt{App\_stm} : \Type \rightarrow \Rml \rightarrow \Rml \rightarrow \Rml \\
  &~~|~ \mathtt{Let\_rec} : (\mathbb{N} * \Type) \rightarrow (\mathbb{N} * \Type) \rightarrow \Rml \rightarrow \Rml \rightarrow \Rml.
\end{align*}
We use all cog types, as possible types of Rml expressions, since there are no real restrictions on the types. We encode variables, as a type and a natural number, so two variables are the same only if they have the same number and refer to the same type.
\\ \\
We have defined a relation \wellformed, that checks that no variables are escaping the scope of an Rml program, that is there is always a binding for an expression of type \(\mathtt{Var}~p\). We furthermore define a relation \valid, which checks that a given Rml expression can be typed under a given type. We have shown that if a Rml program is valid then it is well formed. We have then constructed a simplified form of Rml called sRml (for simple Rml), to make it easier to reason about and evaluate expressions, with the following data structure:
\begin{align*}
  &\mathtt{Inductive}~\sRml : \Type := \\
  &~~|~ \mathtt{sVar} : (\mathbb{N} * \Type) \rightarrow \sRml \\
  &~~|~ \mathtt{sConst} : \forall~(A : \Type),~A \rightarrow \sRml \\
  &~~|~ \mathtt{sIf} : \sRml \rightarrow \sRml \rightarrow \sRml \rightarrow \sRml \\
  &~~|~ \mathtt{sApp} : \Type \rightarrow \sRml \rightarrow \sRml \rightarrow \sRml \\
  &~~|~ \mathtt{sFix} : \forall~(p~p0 : (\mathbb{N} * \Type)),~@\sRml~p.2 \rightarrow @\sRml~(p.2 \rightarrow A) \rightarrow \sRml.
\end{align*}
That is Rml where we remove expressions with variables, from \texttt{let\_stm} statements (not \texttt{let\_rec} statements). We then show that given a valid typing of an Rml expression, we can simplify that expression, and maintain the valid typing (under the same type). With this we can make an interpreter from an interpreter of sRml, which can be constructed as (for continuations). We have a similar function for Rml, using the posibility distributions as interpretations. We see similar patterns arising, since both interpretations are monadic.

\subsection{\texttt{pwhile}}
% Here we should give a quick description of EasyCrypt an present pwhile


\section{Our approach}
% Goal: 6-12 pages

% What we tried to do and the theory behind.

% Describe the translation from while to functional (+recursion), to lambda-calculus,
% to an interpretation in omega-cpos.

% We planned on making an interpretation of Rml in Coq and then translating the xhl
% implementation of pwhile to our abstract syntax. 


\subsection{Translating \texttt{while} to a functional language}
In order to do the translations properly, let us first have a look at a translation
from the simple, widely known \texttt{while} language to a simple functional language
resembling \rml. The thought behind this is that once this translation is in place,
all we have to do to translate \texttt{pwhile} to \rml is to add nondeterminism.

\begin{align}
  \label{eq:while}
  exp~  ::=~~ & x \vert n \vert \texttt{true} \vert \texttt{false} \vert f~x \\
  stm~  ::=~~ & \texttt{skip} \vert x := e
               \vert \texttt{if } e \texttt{ then } s_1 \texttt{ else } s_2
               \vert \texttt{while } e \texttt{ do } s \vert s_1;s_2
\end{align}

The syntax of our functional language is the same as \rml modulo the pre-defined
randomised functions.

The translation of expressions is completely straightforward: variables are mapped to
variables, constants to constants, and function applications to function applications. 

In order to translate statements we choose a set of SML-style matching rules; this
choice is due to the translation of sequences being dependent on what the first
statement is. We will in the following write the translation of a \texttt{while}
statement $s$ to an expression in our functional language as 

Furthermore we need to handle the fact that while the imperative \texttt{while} has a
return memory that one could extract the wished results from, a functional language
has no such thing. We therefore need to choose the memory positions we are interested
in and encapsulate those in a variable. We will, in the following, choose $x_r$ to be
the name of said variable. 

\begin{align}
  \label{eq:transwhile}
  \texttt{skip}~;~s & ~\mapsto~ & \llbracket s \rrbracket\\
  \texttt{skip}     & ~\mapsto~ & x_r\\
  x := e~;~s        & ~\mapsto~ & \texttt{let } x := e \texttt{ in }\llbracket s \rrbracket\\
  x_r := e          & ~\mapsto~ & e \\
  x := e            & ~\mapsto~ & x_r \\
  (\texttt{if } e \texttt{ then } s_1 \texttt{ else } s_2) ~;~s_3
                    & ~\mapsto~ & \texttt{if } e
                                  \texttt{ then } \llbracket s_1 ~;~ s_3 \rrbracket
                                  \texttt{ else } \llbracket s_2 ~;~ s_3 \rrbracket \\
  \texttt{if } e \texttt{ then } s_1 \texttt{ else } s_2
                    & ~\mapsto~ & \texttt{if } e
                                  \texttt{ then } \llbracket s_1 \rrbracket
                                  \texttt{ else } \llbracket s_2 \rrbracket \\
  (\texttt{while } e \texttt{ do } s_1) ~;~ s_2
                    & ~\mapsto~ & \texttt{let rec } f~x :=
                                  \texttt{if } e
                                  \texttt{ then } \llbracket s_1 ~;~ f~x \rrbracket
                                  \texttt{ else } \llbracket s_2 \rrbracket \\
  \texttt{while } e \texttt{ do } s_1
                    & ~\mapsto~ & \texttt{let rec } f~x :=
                                  \texttt{if } e
                                  \texttt{ then } \llbracket s_1 ~;~ f~x \rrbracket
                                  \texttt{ else } x_r 
\end{align}



\subsection{Translation from Rml to typed $\mathbf{\lambda}$-calculus}
\begin{center}
  \begin{tabular}{|c|c|}
    \hline
    Rml & typed $\lambda$-calculus \\ \hline
    Var $(x,A)$ & $x : A$ \\
    Const $A$ $c$ & $c : A$ \\
    Let $(x,A)$ $e_1$ $e_2$ & $(\lambda x : A. e_2)~e_1$ \\
    Fun $(x,A)$ $e$ & $\lambda x : A. e$ \\
    App $e_1$ $e_2$ & $e_1~e_2$ \\
    Let rec $(f,A \rightarrow B)$ $(x,A)$ $e_1$ $e_2$ & $(\lambda f : A \rightarrow B. e_2)~(Y~(\lambda f : A \rightarrow B. \lambda x : A. e_1))$ \\ \hline
  \end{tabular}
\end{center}
The problem here is that we need to translate \(e1\) and \(e2\) to their simple forms, so we do an intermediate translation:
\[Let\]

\subsubsection{Example: Fib}
Expression:
\begin{align*}
\mathtt{Let\_rec}&~(f,\mathbb{N} \rightarrow \mathbb{N})~(x,\mathbb{N})~\\
  (&\mathtt{if}~x \leq 0\\
                 &\mathtt{then}~0\\
                 &\mathtt{else}~f~(x - 1) + f~(x-2))\\
  (&f~3)
\end{align*}
Typing:
\begin{align*}
\mathtt{Let\_rec}&~(f,\mathbb{N} \rightarrow \mathbb{N})~(x,\mathbb{N})~\\
  ((&\mathtt{if}~(x \leq 0 : \mathbb{B})\\
                 &\mathtt{then}~(0 : \mathbb{N})\\
                 &\mathtt{else}~(f : \mathbb{N} \rightarrow \mathbb{N})~(x - 1 : \mathbb{N}) + (f : \mathbb{N} \rightarrow \mathbb{N})~(x-2 : \mathbb{N}) : \mathbb{N}) : \mathbb{N})\\
  (&(f : \mathbb{N} \rightarrow \mathbb{N})~(3 : \mathbb{N}) : \mathbb{N})
\end{align*}
Semi-simple
\begin{align*}
  &\mathtt{Let\_stm}~f \\
  &\quad \mathtt{sFix} \\
  &\quad \quad \mathtt{sFun}~(f,\mathbb{N} \rightarrow \mathbb{N})\\
  &\quad \quad \quad \mathtt{sFun}~(x,\mathbb{N}) \\
  &\quad \quad \quad \quad ((\mathtt{if}~(x \leq 0)\\
  &\quad \quad \quad \quad ~~\mathtt{then}~0\\
  &\quad \quad \quad \quad ~~\mathtt{else}~f~(x - 1) + f~(x-2)))\\
  &\quad (f~3)
\end{align*}
Simple form:
\begin{align*}
  &\mathtt{sApp}~\mathtt{sFix} \\
  &\quad \mathtt{sFun}~(f,\mathbb{N} \rightarrow \mathbb{N})\\
  &\quad \quad \mathtt{sFun}~(x,\mathbb{N}) \\
  &\quad \quad \quad ((\mathtt{if}~(x \leq 0)\\
  &\quad \quad \quad ~~\mathtt{then}~0\\
  &\quad \quad \quad ~~\mathtt{else}~f~(x - 1) + f~(x-2))) \\
  &\quad 3
\end{align*}

\subsection{All translations (forward)}
\begin{center}
  \begin{tabular}{|c|c|c|}
    \hline
    Rml & @sRml A & typed $\lambda$-calculus \\ \hline
    Var $(x,A)$ & sVar $x$ & $x : A$ \\
    Const $A$ $c$ & & $c : A$ \\
    Let $(x,A)$ $e_1$ $e_2$ & & $(\lambda x : A, e_2)~e_1$ \\
    Fun $(x,A)$ $e$ & & $\lambda x : A, e$ \\
    App $e_1$ $e_2$ & & $e_1~e_2$ \\
    Let rec $(f,A \rightarrow B)$ $(x,A)$ $e_1$ $e_2$ & & $(\lambda f : A \rightarrow B, e_2)~(Y~(\lambda f : A \rightarrow B, \lambda x : A, e_1))$ \\ \hline
  \end{tabular}
\end{center}


\section{Our contribution}
% Goal: 6-12 pages
% What we actually did.

% We implemented an abstract syntax for Rml in Coq

% We tried to translate from pwhile to said Rml (syntax to syntax)

% We were able to interpret Rml modulo general recursion, using a probability monad.

% We tried implementing general recursion with the extra step of translating to the
% typed lambda calculus and using a fixpoint combinator.

\section{Comparisons and future work}
% Goal: 2-4 pages
% What the section header says


\section{Conclusion}
% Goal: 1-2 pages



\newpage
\section{Appendix}
Example - Error: Stack Overflow.
\begin{lstlisting}
Fixpoint replace_all_variables_aux_type
         A (x : Rml) (env : seq (nat * Type * Rml))
         (fl : seq (nat * Type)) `{env_valid : valid_env env fl}
         `{x_valid : @rml_valid_type A (map fst env) fl x} : @sRml A
                                                                            
with replace_all_variables_aux_type_const
       A0 A a (env : seq (nat * Type * Rml))
       (fl : seq (nat * Type)) `{env_valid : valid_env env fl}
       `{x_valid : @rml_valid_type A0 (map fst env) fl (Const A a)} : @sRml A0
with replace_all_variables_aux_type_let
       A p x1 x2 (env : seq (nat * Type * Rml))
       (fl : seq (nat * Type)) `{env_valid : valid_env env fl}
       `{x_valid : @rml_valid_type A (map fst env) fl (Let_stm p x1 x2)} : @sRml A
with replace_all_variables_aux_type_fun
       A T p x (env : seq (nat * Type * Rml))
       (fl : seq (nat * Type)) `{env_valid : valid_env env fl}
       `{x_valid : @rml_valid_type A (map fst env) fl (Fun_stm T p x)} : @sRml A
with replace_all_variables_aux_type_if
       A x1 x2 x3 (env : seq (nat * Type * Rml))
       (fl : seq (nat * Type)) `{env_valid : valid_env env fl}
       `{x_valid : @rml_valid_type A (map fst env) fl (If_stm x1 x2 x3)} : @sRml A
with replace_all_variables_aux_type_app
       A T x1 x2 (env : seq (nat * Type * Rml))
       (fl : seq (nat * Type)) `{env_valid : valid_env env fl}
       `{x_valid : @rml_valid_type A (map fst env) fl (App_stm T x1 x2)} : @sRml A
with replace_all_variables_aux_type_let_rec A T T0 n n0 x1 x2 (env : seq (nat * Type * Rml))
     (fl : seq (nat * Type)) `{env_valid : valid_env env fl}
     `{x_valid : @rml_valid_type A (map fst env) fl (Let_rec T T0 n n0 x1 x2)} : @sRml A.
Proof.
  (** Structure **)
  {
    induction x ; intros ; refine (sVar (0,A)).
  }
  
  all: refine (sVar (0,A)).  
Defined.
\end{lstlisting}

\end{document}
