\documentclass[11pt, leqno]{article}
\usepackage{graphicx}

\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage[english]{babel}

\usepackage[left=20mm,right=20mm]{geometry}

\usepackage[hidelinks]{hyperref}

\usepackage{xcolor}

\usepackage{listings}

\lstdefinelanguage{Coq}{ 
%
% Anything betweeen $ becomes LaTeX math mode
mathescape=true,
%
% Comments may or not include Latex commands
texcl=false, 
%
% Vernacular commands
morekeywords=[1]{Section, Module, End, Require, Import, Export,
  Variable, Variables, Parameter, Parameters, Axiom, Hypothesis,
  Hypotheses, Notation, Local, Tactic, Reserved, Scope, Open, Close,
  Bind, Delimit, Definition, Let, Ltac, Fixpoint, CoFixpoint, Add,
  Morphism, Relation, Implicit, Arguments, Unset, Contextual,
  Strict, Prenex, Implicits, Inductive, CoInductive, Record,
  Structure, Canonical, Coercion, Context, Class, Global, Instance,
  Program, Infix, Theorem, Lemma, Corollary, Proposition, Fact,
  Remark, Example, Proof, Goal, Save, Qed, Defined, Hint, Resolve,
  Rewrite, View, Search, Show, Print, Printing, All, Eval, Check,
  Projections, inside, outside, Def},
%
% Gallina
morekeywords=[2]{forall, exists, exists2, fun, fix, cofix, struct,
  match, with, end, as, in, return, let, if, is, then, else, for, of,
  nosimpl, when},
%
% Sorts
morekeywords=[3]{Type, Prop, Set, true, false, option},
%
% Various tactics, some are std Coq subsumed by ssr, for the manual purpose
morekeywords=[4]{pose, set, move, case, elim, apply, clear, hnf,
  intro, intros, generalize, rename, pattern, after, destruct,
  induction, using, refine, inversion, injection, rewrite, congr,
  unlock, compute, ring, field, fourier, replace, fold, unfold,
  change, cutrewrite, simpl, have, suff, wlog, suffices, without,
  loss, nat_norm, assert, cut, trivial, revert, bool_congr, nat_congr,
  symmetry, transitivity, auto, split, left, right, autorewrite},
%
% Terminators
morekeywords=[5]{by, done, exact, reflexivity, tauto, romega, omega,
  assumption, solve, contradiction, discriminate},
%
% Control
morekeywords=[6]{do, last, first, try, idtac, repeat},
% % Custom
morekeywords=[7]{Rml, sRml},
morekeywords=[8]{Var, Const, Let_stm, Fun_stm, If_stm, App_stm, Let_rec},
morekeywords=[9]{sVar, sConst, sFun, sIf, sApp, sFix},
% Comments delimiters, we do turn this off for the manual
morecomment=[s]{(*}{*)},
%
% Spaces are not displayed as a special character
showstringspaces=false,
%
% String delimiters
morestring=[b]",
morestring=[d]Â’,
%
% Size of tabulations
tabsize=3,
%
% Enables ASCII chars 128 to 255
extendedchars=false,
%
% Case sensitivity
sensitive=true,
%
% Automatic breaking of long lines
breaklines=false,
%
% Default style fors listings
basicstyle=\small,
%
% Position of captions is bottom
captionpos=b,
%
% flexible columns
columns=[l]flexible,
%
% Style for (listings') identifiers
identifierstyle={\ttfamily\color{black}},
% Style for declaration keywords
keywordstyle=[1]{\ttfamily\color{violet}},
% Style for gallina keywords
keywordstyle=[2]{\ttfamily\color{green}},
% Style for sorts keywords
keywordstyle=[3]{\ttfamily\color{blue}},
% Style for tactics keywords
keywordstyle=[4]{\ttfamily\color{blue}},
% Style for terminators keywords
keywordstyle=[5]{\ttfamily\color{red}},
%Style for iterators
%keywordstyle=[6]{\ttfamily\color{dkpink}},
keywordstyle=[7]{\ttfamily\color{orange}},
keywordstyle=[8]{\ttfamily\color{red}},
keywordstyle=[9]{\ttfamily\color{magenta}},
% Style for strings
stringstyle=\ttfamily,
% Style for comments
commentstyle={\ttfamily\color{purple}},
%
%moredelim=**[is][\ttfamily\color{red}]{/&}{&/},
literate=
    {\\forall}{{\color{dkgreen}{$\forall\;$}}}1
    {\\exists}{{$\exists\;$}}1
    {<-}{{$\leftarrow\;$}}1
    {=>}{{$\Rightarrow\;$}}1
    {==}{{\code{==}\;}}1
    {==>}{{\code{==>}\;}}1
%    {:>}{{\code{:>}\;}}1
    {->}{{$\rightarrow\;$}}1
    {<->}{{$\leftrightarrow\;$}}1
    {<==}{{$\leq\;$}}1
    {\#}{{$^\star$}}1 
    {\\o}{{$\circ\;$}}1 
    {\@}{{$\cdot$}}1 
    {\/\\}{{$\wedge\;$}}1
    {\\\/}{{$\vee\;$}}1
    {++}{{\code{++}}}1
    {~}{{\ }}1
    {nat}{{$\mathbb{N}$}}1
    {forall}{{$\forall$}}1
    {\@\@}{{$@$}}1
    {\\mapsto}{{$\mapsto\;$}}1
    {\\hline}{{\rule{\linewidth}{0.5pt}}}1
%
}[keywords,comments,strings]

\lstnewenvironment{coq}{\lstset{language=Coq}}{}

% pour inliner dans le texte
\def\coqe{\lstinline[language=Coq, basicstyle=\small]}
% pour inliner dans les tableaux / displaymath...
\def\coqes{\lstinline[language=Coq, basicstyle=\scriptsize]}

% \lstdefinelanguage{rml}{
% }

% \lstdefinelanguage{pwhile}{
% }

\author{Lasse Letager Hansen 201508114}
\date{\today}
\title{Technical report}

\newcommand{\set}[1]{\{#1\}}

\newcommand{\Rml}{\textcolor{orange}{\mathtt{Rml}}}
\newcommand{\sRml}{\textcolor{orange}{\mathtt{sRml}}}
\newcommand{\Type}{\textcolor{blue}{\mathtt{Type}}}
\newcommand{\wellformed}{\texttt{well\_formed}}
\newcommand{\valid}{\texttt{rml\_valid\_type}}
\newcommand{\bind}{\textcolor{magenta}{>\!\!>\!\!=}}

\begin{document}

\maketitle

\section{Rml}
We have two representations of Rml, continuations and distributions. Both build on a monad, for ease of use.
\\ \\
The data structure used to represent Rml terms is as follows:
\begin{center}
  \begin{minipage}{0.7\linewidth}
    \begin{lstlisting}[language=coq]
Inductive Rml :=
| Var : (nat * Type) -> Rml
| Const : forall (A : Type), A -> Rml
| Let_stm : (nat * Type) -> Rml -> Rml -> Rml
| Fun_stm : Type -> (nat * Type) -> Rml -> Rml
| If_stm : Rml -> Rml -> Rml -> Rml
| App_stm : Type -> Rml -> Rml -> Rml
| Let_rec : Type -> Type -> nat -> nat -> Rml -> Rml -> Rml.
    \end{lstlisting}
  \end{minipage}
\end{center}
We use all cog types, as possible types of Rml expressions, since there are no real restrictions on the types. We encode variables, as a type and a natural number, so two variables are the same only if they have the same number and refer to the same type.
\\ \\
We have defined a relation \wellformed, that checks that no variables are escaping the scope of an Rml program, that is there is always a binding for an expression of type \(\mathtt{Var}~p\). We furthermore define a relation \valid, which checks that a given Rml expression can be typed under a given type. We have shown that if a Rml program is valid then it is well formed. We have then constructed a simplified form of Rml called sRml (for simple Rml), to make it easier to reason about and evaluate expressions, with the following data structure:
\begin{center}
  \begin{minipage}{0.7\linewidth}
    \begin{lstlisting}[language=coq]
Inductive sRml {A : Type} :=
| sVar : nat -> sRml
| sConst : A -> sRml
| sFun : forall C (p : nat * Type), A = (p.2 -> C) -> @sRml C -> sRml
| sIf : @sRml bool -> sRml -> sRml -> sRml
| sApp : forall T, @sRml (T -> A) -> @sRml T -> sRml
| sFix : forall B (nf nx : nat), @sRml (B -> A) -> @sRml B -> sRml.
    \end{lstlisting}
  \end{minipage}
\end{center}
That is Rml where we remove expressions with variables, from \texttt{let\_stm} statements (not \texttt{let\_rec} statements). We then show that given a valid typing of an Rml expression, we can simplify that expression, and maintain the valid typing (under the same type). With this we can make an interpreter from an interpreter of sRml, which can be constructed as (for continuations). We have a similar function for Rml, using the posibility distributions as interpretations. We see similar patterns arising, since both interpretations are monadic.

\section{Translation from Rml to typed $\mathbf{\lambda}$-calculus}
\begin{center}
  \begin{tabular}{|c|c|}
    \hline
    Rml & typed $\lambda$-calculus \\ \hline
    Var $(x,A)$ & $x : A$ \\
    Const $A$ $c$ & $c : A$ \\
    Let $(x,A)$ $e_1$ $e_2$ & $(\lambda x : A, e_2)~e_1$ \\
    Fun $(x,A)$ $e$ & $\lambda x : A, e$ \\
    App $e_1$ $e_2$ & $e_1~e_2$ \\
    Let rec $(f,A \rightarrow B)$ $(x,A)$ $e_1$ $e_2$ & $(\lambda f : A \rightarrow B, e_2)~(Y~(\lambda f : A \rightarrow B, \lambda x : A, e_1))$ \\ \hline
  \end{tabular}
\end{center}
The problem here is that we need to translate \(e1\) and \(e2\) to their simple forms, so we do an intermediate translation:
\[Let\]

\subsection{Example: Fib}
Expression:
\begin{align*}
\mathtt{Let\_rec}&~(f,\mathbb{N} \rightarrow \mathbb{N})~(x,\mathbb{N})~\\
  (&\mathtt{if}~x \leq 0\\
                 &\mathtt{then}~0\\
                 &\mathtt{else}~f~(x - 1) + f~(x-2))\\
  (&f~3)
\end{align*}
Typing:
\begin{align*}
\mathtt{Let\_rec}&~(f,\mathbb{N} \rightarrow \mathbb{N})~(x,\mathbb{N})~\\
  ((&\mathtt{if}~(x \leq 0 : \mathbb{B})\\
                 &\mathtt{then}~(0 : \mathbb{N})\\
                 &\mathtt{else}~(f : \mathbb{N} \rightarrow \mathbb{N})~(x - 1 : \mathbb{N}) + (f : \mathbb{N} \rightarrow \mathbb{N})~(x-2 : \mathbb{N}) : \mathbb{N}) : \mathbb{N})\\
  (&(f : \mathbb{N} \rightarrow \mathbb{N})~(3 : \mathbb{N}) : \mathbb{N})
\end{align*}
Semi-simple
\begin{align*}
  &\mathtt{Let\_stm}~f \\
  &\quad \mathtt{sFix} \\
  &\quad \quad \mathtt{sFun}~(f,\mathbb{N} \rightarrow \mathbb{N})\\
  &\quad \quad \quad \mathtt{sFun}~(x,\mathbb{N}) \\
  &\quad \quad \quad \quad ((\mathtt{if}~(x \leq 0)\\
  &\quad \quad \quad \quad ~~\mathtt{then}~0\\
  &\quad \quad \quad \quad ~~\mathtt{else}~f~(x - 1) + f~(x-2)))\\
  &\quad (f~3)
\end{align*}
Simple form:
\begin{align*}
  &\mathtt{sApp}~\mathtt{sFix} \\
  &\quad \mathtt{sFun}~(f,\mathbb{N} \rightarrow \mathbb{N})\\
  &\quad \quad \mathtt{sFun}~(x,\mathbb{N}) \\
  &\quad \quad \quad ((\mathtt{if}~(x \leq 0)\\
  &\quad \quad \quad ~~\mathtt{then}~0\\
  &\quad \quad \quad ~~\mathtt{else}~f~(x - 1) + f~(x-2))) \\
  &\quad 3
\end{align*}

\section{All translations (forward)}
\begin{center}
  \rotatebox{0}{
    \resizebox{1.05\linewidth}{!}{
      \begin{tabular}{|c|c|c|}
        \hline
        Rml & @sRml A & typed $\lambda$-calculus \\ \hline
        Var $(x,A)$ & sVar $x$ & $x : A$ \\
        Const $A$ $c$ & sConst c & $c : A$ \\
        Let $(x,T)$ $e_1$ $e_2$ & $e_2'$ & $(\lambda x : T, e_2 : A)~(e_1 : T) : A$ \\
        Fun $(x,T)$ $e$ & sFun $S$ $(x,T)$ $e'$ & $(\lambda x : T, e : S) : T \rightarrow S$ \\
        App $T$ $e_1$ $e_2$ & sApp $T$ $e_1'$ $e_2'$ & $(e_1 : T \rightarrow A)~(e_2 : T) : A$ \\ && \\
        Let rec $T$ $S$ $f$ $x$ $e_1$ $e_2$ &
                                              \begin{tabular}{l}
                                                sApp $(T \rightarrow S)$ \\
                                                \quad (sFun $A$ $(f,T \rightarrow S)$ $e_2'$) \\
                                                \quad (sFun $S$ $(x,T)$\\
                                                \quad \quad (sFix $T$ $f$ $x$ $e_1'$ (sVar $x$)))
                                              \end{tabular}
&
                                                              \begin{tabular}{l}
                                                                $(\lambda f : T \rightarrow S, e_2 : A)$\\
                                                                \quad $(Y~(\lambda f : T \rightarrow S, \lambda x : T, e_1 : S) : T \rightarrow S) : A$
                                                              \end{tabular}
\\ \hline
      \end{tabular}
    }}
\end{center}

\section{Appendix}
Example - Error: Stack Overflow.
\begin{lstlisting}[language=coq]
Fixpoint replace_all_variables_aux_type
         A (x : Rml) (env : seq (nat * Type * Rml))
         (fl : seq (nat * Type)) `{env_valid : valid_env env fl}
         `{x_valid : @rml_valid_type A (map fst env) fl x} : @sRml A
                                                                            
with replace_all_variables_aux_type_const
       A0 A a (env : seq (nat * Type * Rml))
       (fl : seq (nat * Type)) `{env_valid : valid_env env fl}
       `{x_valid : @rml_valid_type A0 (map fst env) fl (Const A a)} : @sRml A0
with replace_all_variables_aux_type_let
       A p x1 x2 (env : seq (nat * Type * Rml))
       (fl : seq (nat * Type)) `{env_valid : valid_env env fl}
       `{x_valid : @rml_valid_type A (map fst env) fl (Let_stm p x1 x2)} : @sRml A
with replace_all_variables_aux_type_fun
       A T p x (env : seq (nat * Type * Rml))
       (fl : seq (nat * Type)) `{env_valid : valid_env env fl}
       `{x_valid : @rml_valid_type A (map fst env) fl (Fun_stm T p x)} : @sRml A
with replace_all_variables_aux_type_if
       A x1 x2 x3 (env : seq (nat * Type * Rml))
       (fl : seq (nat * Type)) `{env_valid : valid_env env fl}
       `{x_valid : @rml_valid_type A (map fst env) fl (If_stm x1 x2 x3)} : @sRml A
with replace_all_variables_aux_type_app
       A T x1 x2 (env : seq (nat * Type * Rml))
       (fl : seq (nat * Type)) `{env_valid : valid_env env fl}
       `{x_valid : @rml_valid_type A (map fst env) fl (App_stm T x1 x2)} : @sRml A
with replace_all_variables_aux_type_let_rec A T T0 n n0 x1 x2 (env : seq (nat * Type * Rml))
     (fl : seq (nat * Type)) `{env_valid : valid_env env fl}
     `{x_valid : @rml_valid_type A (map fst env) fl (Let_rec T T0 n n0 x1 x2)} : @sRml A.
Proof.
  (** Structure **)
  {
    induction x ; intros ; refine (sVar (0,A)).
  }
  
  all: refine (sVar (0,A)).  
Defined.
\end{lstlisting}

\end{document}
